package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io"
	"sort"
	"strings"
	"text/template"

	"github.com/dustin/go-humanize/english"
)

type Generator struct {
	Package        string
	Service        *Service
	ServiceConfig  ServiceConfig
	Resource       *Resource
	ResourceConfig ResourceConfig
	CloudFormation CloudFormationResource
}

func (g *Generator) GeneratePkgDoc(w io.Writer) error {
	fmt.Fprintf(w, "// Package %s provides resources for %s.\n", g.Package, g.Service.Metadata.ServiceFullName)
	fmt.Fprintf(w, "package %s\n", g.Package)
	return nil
}

func (g *Generator) GeneratePkgRegister(w io.Writer, resources []*Resource) error {
	tmpl := template.Must(template.New("").Parse(`// Code generated by awsgen from api. DO NOT EDIT.

package {{.Package}}

import "reflect"

// Registry maintains a list of supported {{.Package}} resources.
type Registry interface {
	Add(typename string, typ reflect.Type)
}

// Register registers all {{.Service}} resources.
func Register(reg Registry) {
{{- range .Resources}}
	reg.Add("{{.Typename}}", reflect.TypeOf(&{{.Type}}{}))
{{- end}}
}
`))

	type regRes struct{ Typename, Type string }
	rr := make([]regRes, len(resources))
	for i, res := range resources {
		rr[i] = regRes{
			Typename: ResourceType(g.Service.Metadata.ServiceID, res.Name),
			Type:     ResourceName(res.Name),
		}
	}

	return tmpl.Execute(w, map[string]interface{}{
		"Package":   g.Package,
		"Service":   g.Service.Metadata.ServiceFullName,
		"Resources": rr,
	})
}

func (g *Generator) GenerateResource(w io.Writer) error {
	res := g.Resource

	var buf bytes.Buffer

	svcName := g.Service.Metadata.ServiceFullName
	resName := ResourceName(res.Name)

	// if resName != "Role" {
	// 	fmt.Println("TEMP SKIP", resName)
	// 	return nil
	// }

	resCfg := g.ServiceConfig.Resources[res.Name]

	// Code gen header
	fmt.Fprintf(&buf, "// Code generated by awsgen from api version %s. DO NOT EDIT.\n\n", g.Service.Metadata.APIVersion)

	// Package
	fmt.Fprintf(&buf, "package %s\n", g.Package)
	fmt.Fprintf(&buf, "\n")

	// Imports
	var imports []string
	if res.Create.Input.HasTimestamp() || res.Create.Output.HasTimestamp() {
		imports = append(imports, "time")
	}

	switch len(imports) {
	case 0:
		// No imports
	case 1:
		// Single; print inline
		fmt.Fprintf(&buf, "import %q\n", imports[0])
	default:
		// More than one; multiple lines
		fmt.Fprintf(&buf, "import (\n")
		for _, v := range imports {
			fmt.Fprintf(&buf, "%q\n", v)
		}
		fmt.Fprintf(&buf, ")\n")
	}

	// Resource
	var doc *Doc
	if resCfg.Doc != "" {
		doc = ParseDoc(resCfg.Doc)
	} else {
		pluralName := english.PluralWord(2, resName, "")
		doc = Docf("%s manages %s %s.", resName, svcName, pluralName)
	}
	PrintComment(&buf, doc.GoDoc())
	fmt.Fprintf(&buf, "type %s struct {\n", resName)
	input := res.Create.Input
	if len(input) > 0 {
		g.printStruct(&buf, "input", res.Create.Input, nil)
	}
	output := res.Create.Output
	if len(resCfg.Output) > 0 {
		outPath := Path(strings.Split(resCfg.Output, "."))
		output = output.FieldByPath(outPath).Type.(Struct)
	}
	output = output.Exclude(input.FieldNames())
	if len(output) > 0 {
		fmt.Fprint(&buf, "\n// Outputs:\n\n")
		g.printStruct(&buf, "output", output, nil)
	}
	fmt.Fprintf(&buf, "}\n")

	// CloudFormation type
	if typ := g.CloudFormation.Type; typ != "" {
		fmt.Fprintf(&buf, "// CloudFormationType returns the CloudFormation type for a %s %s.\n", svcName, resName)
		fmt.Fprintf(&buf, "func (%s) CloudFormationType() string { return %q }\n", resName, typ)
	}

	// Additional methods
	for _, method := range resCfg.Methods {
		tmpl, err := template.New("").Parse(method)
		if err != nil {
			return err
		}
		tmpl.Execute(&buf, map[string]string{
			"Type": resName,
		})
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Println(buf.String())
		return fmt.Errorf("gofmt: %w", err)
	}

	if _, err := w.Write(src); err != nil {
		return err
	}
	return nil
}

func (g *Generator) printStruct(w io.Writer, direction string, s Struct, parent Path) {
	for i, f := range s {
		path := append(parent, f.Name)

		cfg := g.ResourceConfig.Fields[path.String()]
		tag := tag{}

		var fieldName, inputName string

		if cfg.Name != "" {
			fieldName = cfg.Name
		} else {
			fieldName = FieldName(f.Name)
		}

		if cfg.Input != "" {
			inputName = cfg.Input
		} else {
			inputName = InputName(fieldName)
		}

		var doc *Doc
		if cfg.Doc != "" {
			// Custom doc
			doc = ParseDoc(cfg.Doc)
		} else {
			// Doc from API
			doc = f.Doc
		}
		if doc != nil {
			if i > 0 {
				// Extra space before comment
				fmt.Fprint(w, "\n")
			}
			PrintComment(w, doc.GoDoc())
		}

		if fieldName != f.Name {
			tag["json"] = f.Name
		}
		if !cfg.NoInput {
			tag[direction] = inputName
		}

		if value := cfg.CloudFormation; value != "" {
			// Custom
			tag["cloudformation"] = value
		} else if prop := g.CloudFormation.Properties.FieldByPath(path); prop.Name != "" {
			// Input..
			value := prop.Name
			if attr := g.CloudFormation.Attributes.FieldByPath(path); attr.Name != "" {
				// ..and output
				value += ",att"
			}
			tag["cloudformation"] = value
		} else if attr := g.CloudFormation.Attributes.FieldByPath(path); attr.Name != "" {
			// Output only
			tag["cloudformation"] = attr.Name + ",att"
		}

		fmt.Fprint(w, fieldName)
		fmt.Fprint(w, " ")
		if pointer(f) {
			fmt.Fprint(w, "*")
		}
		g.printType(w, direction, f.Type, path)
		tag.Write(w)
		fmt.Fprint(w, "\n")

		if doc != nil {
			// Ensure extra space after comment. Gofmt will trim duplicate spaces.
			fmt.Fprint(w, "\n")
		}
	}
}

type tag map[string]string

func (t tag) Write(w io.Writer) {
	if len(t) == 0 {
		return
	}
	keys := make([]string, 0, len(t))
	for k := range t {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	fmt.Fprint(w, "`")
	for i, k := range keys {
		if i > 0 {
			fmt.Fprint(w, " ")
		}
		fmt.Fprintf(w, "%s:%q", k, t[k])
	}
	fmt.Fprint(w, "`")
}

func pointer(f Field) bool {
	if f.Required {
		return false
	}
	if _, ok := f.Type.(List); ok {
		return false
	}
	if _, ok := f.Type.(Map); ok {
		return false
	}
	if _, ok := f.Type.(Binary); ok {
		return false
	}
	return true
}

func (g *Generator) printType(w io.Writer, tag string, t Type, path Path) {
	switch val := t.(type) {
	case Struct:
		fmt.Fprint(w, "struct {\n")
		g.printStruct(w, tag, val, path)
		fmt.Fprint(w, "}")
	case String:
		fmt.Fprint(w, "string")
	case Int:
		fmt.Fprint(w, "int")
	case Float:
		fmt.Fprint(w, "float64")
	case Bool:
		fmt.Fprint(w, "bool")
	case Timestamp:
		fmt.Fprint(w, "time.Time")
	case Binary:
		fmt.Fprint(w, "[]byte")
	case List:
		fmt.Fprint(w, "[]")
		g.printType(w, tag, val.Element, path)
	case Map:
		fmt.Fprint(w, "map[")
		g.printType(w, tag, val.Key, path)
		fmt.Fprint(w, "]")
		g.printType(w, tag, val.Key, path)
	default:
		panic(fmt.Sprintf("Unhandled: %T", t))
	}
}
